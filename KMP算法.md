### 1、KMP算法

----------在O(N)时间内解决----------------

最长前缀后缀匹配长度，先记为L

一串字符串，其中每一个字符计算出一个信息，即上面的L，L与当前字符k本身是什么无关，而是与它前面的字符串有关，如

"abbabbk"，对于字符k来说，当 L=3 时候，前缀为abb，后缀为abb，所以此时L是3，再大了就都不相等了，注意，k前面有6个字符，L最大为5，不能取6

当判断字符串 2 是否在字符串 1 中时候：

---------是对字符串2中的每一个字符计算L----------！！！！

①：对于字符串2中的第一个字符，前面没东西，人为规定L=-1

②：对于第二个字符，之前只有一个，且不能取整体，所以人为规定L=0

----------------------------------

通过上面步骤，得到一个数组，记为next，记录了最长前缀后缀匹配长度

通过这个数组，进行加速求解

-----------------------

从字符串1的开头开始比对，当遇到第一个不同的字符时候，此时在字符串1里的记为x，在字符串2里的记为y

下一次比对：字符串2的y跳到next[y.index]的下一位，字符串1比对位置不变，还是x（但此时是从x.index-L的地方开始匹配的，只是这一段一定是一样的，所以还是从x开始继续匹配）

算法：当i1,i2小于他们分别的字符串长度时候，在里面不停的匹配

如果出来后i2等于字符串2的长度，返回i1-i2，不然返回-1

##### ①、next数组求法

前两位是人为固定的，第三位也好算（比对第一位第二位就行了）

计算i位置时候的前缀，比对i-1位置和next[i-1]位置，如果一样，则next[i]=next[i-1]+1，否则的话：

next[i-1]记为y，则比对next[y]和i-1，如果等于，next[i]=next[y]+1，如果一直跳到最前，没法跳了，还是没有相等，则这个位置的L=0






### 2、Manacher算法

字符串中，最长回文子串的长度求解

