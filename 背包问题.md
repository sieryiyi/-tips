## 背包问题

### 0-1背包问题（可用dp进行求解）

0-1指的是是否选择当前物品，背包问题要求所选物品不能超过背包容量

可进行转化：

如所求问题正好等于容量 https://leetcode.cn/problems/NUPfPr/

```
# 二维dp
        n=len(nums)
        if n<2:
            return False
        a=sum(nums)

        if a%2==1:
            return False
        a=a//2

        if max(nums)>a:
            return False # 最大的数自成一组都大于目标值

        # 动态规划解决背包问题
        dp=[[False]*(a+1) for _ in range(n)]
        for i in range(n):
            dp[i][0]=True
        dp[0][nums[0]]=True # 背包容量恰好等于第i个nums取值的时候

        for i in range(1,n):
            num=nums[i]
            for j in range(1,a+1):
                if a>nums[i]:
                    dp[i][j]=dp[i-1][j]|dp[i-1][j-num]
                else:
                    dp[i][j]=dp[i-1][j]
        return dp[-1][-1]
```

```
# 用滚动数组优化为一维dp，节省空间

        # 动态规划解决背包问题
        dp=[True]+[False]*a  # 第一位是True 表示总容量是0时候，一定是True(不选择任何数字)
        
        for i in range(1,n):
            for j in range(a,nums[i]-1,-1):  # j<nums[i]时，不选择nums[i]，此时dp[j]=dp[j]
                
                dp[j]|=dp[j-nums[i]]
                
        return dp[-1]

```




所求问题不是0-1，而是加上/减去此物品，即 ±1背包问题 https://leetcode.cn/problems/target-sum/solution/
